# Autogenerated by autotester

require 'rails_helper'

RSpec.describe AddOns::InstallHelmChart, type: :action do
  let(:mock_client) { instance_double(K8::Helm::Client) }
  let(:mock_kubectl) { instance_double(K8::Kubectl) }
  let(:add_on) { instance_double('AddOn', name: 'test-addon', chart_type: 'test-chart', cluster: cluster, values: {}, helm_chart_url: 'chart-url', persisted?: persisted) }
  let(:cluster) { instance_double('Cluster', kubeconfig: 'kubeconfig') }
  let(:persisted) { true }
  
  before do
    allow(K8::Helm::Client).to receive(:new).and_return(mock_client)
    allow(K8::Kubectl).to receive(:new).and_return(mock_kubectl)
    allow(mock_client).to receive(:ls).and_return(installed_charts)
    allow(mock_kubectl).to receive(:apply_yaml)
  end

  describe '.executed' do
    subject(:execute_action) { described_class.execute(add_on: add_on) }
    
    context 'when the add-on is not persisted' do
      let(:persisted) { false }
      
      before do
        allow(add_on).to receive(:installing!)
      end
      
      it 'sets the add-on state to installing' do
        execute_action
        expect(add_on).to have_received(:installing!)
      end
    end

    context 'when the add-on is persisted' do
      before do
        allow(add_on).to receive(:updating!)
      end

      it 'sets the add-on state to updating' do
        execute_action
        expect(add_on).to have_received(:updating!)
      end
    end

    context 'when the helm chart is not installed' do
      let(:installed_charts) { [] }

      before do
        allow(mock_client).to receive(:install)
        allow(add_on).to receive(:installed!)
      end

      it 'installs the helm chart' do
        execute_action
        expect(mock_client).to have_received(:install)
      end

      it 'sets the add-on state to installed' do
        execute_action
        expect(add_on).to have_received(:installed!)
      end
    end

    context 'when the helm chart is already installed' do
      let(:installed_charts) { [{ 'name' => 'test-addon' }] }

      it 'does not install the helm chart again' do
        execute_action
        expect(mock_client).not_to have_received(:install)
      end
    end

    context 'when an error occurs' do
      let(:installed_charts) { [] }

      before do
        allow(mock_client).to receive(:install).and_raise(StandardError, 'installation error')
        allow(add_on).to receive(:failed!)
        allow(add_on).to receive(:error)
      end

      it 'sets the add-on state to failed' do
        expect { execute_action }.to raise_error(StandardError, 'installation error')
        expect(add_on).to have_received(:failed!)
      end

      it 'logs the error message' do
        expect { execute_action }.to raise_error(StandardError, 'installation error')
        expect(add_on).to have_received(:error).with('installation error')
      end
    end
  end

  describe '.create_namespace' do
    let(:namespace_yaml) { 'namespace_yaml_content' }
    before do
      allow(K8::Namespace).to receive(:new).and_return(instance_double(K8::Namespace, to_yaml: namespace_yaml))
    end

    it 'applies the namespace yaml' do
      described_class.create_namespace(add_on)
      expect(mock_kubectl).to have_received(:apply_yaml).with(namespace_yaml)
    end
  end

  describe '.get_values' do
    let(:metadata) { { 'template' => { 'key1' => 'value1', 'key2.size' => { 'type' => 'size', 'value' => '100', 'unit' => 'Mi' } } } }
    let(:values) { {} }

    before do
      allow(add_on).to receive(:metadata).and_return(metadata)
      allow(add_on).to receive(:values).and_return(values)
    end

    it 'merges the template variables into values' do
      result = described_class.get_values(add_on)
      expect(result['key1']).to eq('value1')
      expect(result['key2.size']).to eq('100Mi')
    end
  end
end
