# Autogenerated by autotester

require 'rails_helper'

RSpec.describe ClustersController, type: :controller do
  let(:user) { create(:user) }
  let(:account) { create(:account, owner: user) }
  let!(:cluster) { create(:cluster, account: account) }

  before do
    sign_in user
    allow(controller).to receive(:current_account).and_return(account)
  end

  describe 'GET #index' do
    it 'assigns @clusters' do
      get :index
      expect(assigns(:clusters)).to eq([cluster])
    end

    it 'orders clusters by created_at by default' do
      another_cluster = create(:cluster, account: account, created_at: 1.day.from_now)
      get :index
      expect(assigns(:clusters)).to eq([cluster, another_cluster])
    end

    it 'orders clusters by specified column' do
      another_cluster = create(:cluster, account: account, name: 'a-cluster')
      get :index, params: { sort: 'name' }
      expect(assigns(:clusters)).to eq([another_cluster, cluster])
    end
  end

  describe 'GET #show' do
    it 'assigns the requested cluster to @cluster' do
      get :show, params: { id: cluster }
      expect(assigns(:cluster)).to eq(cluster)
    end
  end

  describe 'GET #new' do
    it 'assigns a new Cluster to @cluster' do
      get :new
      expect(assigns(:cluster)).to be_a_new(Cluster)
    end
  end

  describe 'GET #edit' do
    it 'assigns the requested cluster to @cluster' do
      get :edit, params: { id: cluster }
      expect(assigns(:cluster)).to eq(cluster)
    end
  end

  describe 'POST #create' do
    context 'with valid attributes' do
      it 'creates a new cluster' do
        expect {
          post :create, params: { cluster: attributes_for(:cluster) }
        }.to change(Cluster, :count).by(1)
      end

      it 'redirects to the new cluster' do
        post :create, params: { cluster: attributes_for(:cluster) }
        expect(response).to redirect_to(Cluster.last)
      end
    end

    context 'with invalid attributes' do
      it 'does not save the new cluster' do
        expect {
          post :create, params: { cluster: attributes_for(:cluster, name: nil) }
        }.to_not change(Cluster, :count)
      end

      it 're-renders the new method' do
        post :create, params: { cluster: attributes_for(:cluster, name: nil) }
        expect(response).to render_template(:new)
      end
    end
  end

  describe 'PATCH #update' do
    context 'with valid attributes' do
      it 'updates the cluster' do
        patch :update, params: { id: cluster, cluster: { name: 'new-name' } }
        cluster.reload
        expect(cluster.name).to eq('new-name')
      end

      it 'redirects to the updated cluster' do
        patch :update, params: { id: cluster, cluster: { name: 'new-name' } }
        expect(response).to redirect_to(cluster)
      end
    end

    context 'with invalid attributes' do
      it 'does not change the cluster' do
        name = cluster.name
        patch :update, params: { id: cluster, cluster: { name: nil } }
        cluster.reload
        expect(cluster.name).to eq(name)
      end

      it 're-renders the edit method' do
        patch :update, params: { id: cluster, cluster: { name: nil } }
        expect(response).to render_template(:edit)
      end
    end
  end

  describe 'DELETE #destroy' do
    it 'deletes the cluster' do
      expect {
        delete :destroy, params: { id: cluster }
      }.to change(Cluster, :count).by(-1)
    end

    it 'redirects to clusters#index' do
      delete :destroy, params: { id: cluster }
      expect(response).to redirect_to(clusters_url)
    end
  end

  describe 'POST #retry_install' do
    it 'enqueues the InstallJob' do
      expect(Clusters::InstallJob).to receive(:perform_later).with(cluster)
      post :retry_install, params: { id: cluster }
    end

    it 'redirects to the cluster with a notice' do
      post :retry_install, params: { id: cluster }
      expect(response).to redirect_to(cluster)
      expect(flash[:notice]).to eq("Retrying installation for cluster...")
    end
  end

  describe 'POST #check_k3s_ip_address' do
    context 'when the IP address is reachable' do
      before do
        allow(TCPSocket).to receive(:new).and_return(double(close: true))
      end

      it 'returns success' do
        post :check_k3s_ip_address, params: { ip_address: '192.168.1.1' }
        expect(response).to have_http_status(:ok)
        expect(JSON.parse(response.body)).to eq('success' => true)
      end
    end

    context 'when the IP address is unreachable' do
      before do
        allow(TCPSocket).to receive(:new).and_raise(Errno::ECONNREFUSED)
      end

      it 'returns an error' do
        post :check_k3s_ip_address, params: { ip_address: '192.168.1.1' }
        expect(response).to have_http_status(:unprocessable_entity)
        expect(JSON.parse(response.body)).to eq('success' => false, 'error' => "Connection refused")
      end
    end
  end

  describe 'GET #download_kubeconfig' do
    it 'sends the kubeconfig as yaml' do
      expect(controller).to receive(:send_data).with(cluster.kubeconfig.to_yaml, hash_including(filename: "#{cluster.name}-kubeconfig.yml"))
      get :download_kubeconfig, params: { id: cluster }
    end
  end

  describe 'GET #download_yaml' do
    before do
      allow(K8::Kubectl).to receive_message_chain(:new, :call).and_return("---\nitems:\n  - metadata:\n      name: example")
    end

    it 'sends a zip file' do
      expect(controller).to receive(:send_data).with(kind_of(String), hash_including(filename: "#{cluster.name}.zip"))
      get :download_yaml, params: { id: cluster }
    end
  end
end
