# Autogenerated by autotester

require 'rails_helper'

RSpec.describe Project, type: :model do
  describe 'associations' do
    it { is_expected.to belong_to(:cluster) }
    it { is_expected.to have_one(:account).through(:cluster) }
    it { is_expected.to have_many(:users).through(:account) }
    it { is_expected.to have_many(:services).dependent(:destroy) }
    it { is_expected.to have_many(:environment_variables).dependent(:destroy) }
    it { is_expected.to have_many(:builds).dependent(:destroy) }
    it { is_expected.to have_many(:deployments).through(:builds) }
    it { is_expected.to have_many(:domains).through(:services) }
    it { is_expected.to have_many(:events).dependent(:destroy) }
    it { is_expected.to have_many(:volumes).dependent(:destroy) }
    it { is_expected.to have_one(:project_credential_provider).dependent(:destroy) }
  end

  describe 'validations' do
    subject { create(:project) }

    it { is_expected.to validate_presence_of(:name) }
    it { is_expected.to validate_presence_of(:repository_url) }

    it do
      is_expected.to validate_uniqueness_of(:name)
        .scoped_to(:cluster_id)
    end

    it do
      is_expected.to allow_value('valid-name').for(:name)
      is_expected.not_to allow_value('Invalid Name').for(:name)
    end

    it do
      is_expected.to allow_value('owner/repo').for(:repository_url)
      is_expected.not_to allow_value('invalid_repo').for(:repository_url)
    end
  end

  describe 'enums' do
    it { is_expected.to define_enum_for(:status).with_values({ creating: 0, deployed: 1, destroying: 2 }) }
  end

  describe 'methods' do
    let(:project) { create(:project) }

    describe '#current_deployment' do
      let!(:completed_deployment) { create(:deployment, project: project, status: :completed) }
      let!(:pending_deployment) { create(:deployment, project: project, status: :pending) }

      it 'returns the latest completed deployment' do
        expect(project.current_deployment).to eq(completed_deployment)
      end
    end

    describe '#last_build' do
      let!(:old_build) { create(:build, project: project, created_at: 1.day.ago) }
      let!(:latest_build) { create(:build, project: project, created_at: Time.current) }

      it 'returns the last created build' do
        expect(project.last_build).to eq(latest_build)
      end
    end

    describe '#last_deployment' do
      let!(:older_deployment) { create(:deployment, project: project, created_at: 1.day.ago) }
      let!(:latest_deployment) { create(:deployment, project: project, created_at: Time.current) }

      it 'returns the last created deployment' do
        expect(project.last_deployment).to eq(latest_deployment)
      end
    end

    describe '#last_deployment_at' do
      context 'when there is a last deployment' do
        let!(:latest_deployment) { create(:deployment, project: project, created_at: Time.current) }

        it 'returns the created_at of the last deployment' do
          expect(project.last_deployment_at).to eq(latest_deployment.created_at)
        end
      end

      context 'when there is no deployment' do
        it 'returns nil' do
          expect(project.last_deployment_at).to be_nil
        end
      end
    end

    describe '#repository_name' do
      it 'returns the last part of the repository_url' do
        expect(project.repository_name).to eq('repository')
      end
    end

    describe '#full_repository_url' do
      it 'returns the full GitHub repository URL' do
        expect(project.full_repository_url).to eq('https://github.com/owner/repository')
      end
    end

    describe '#github_access_token' do
      let(:account) { project.account }
      let(:project_credential_provider) { project.project_credential_provider }

      context 'when project_credential_provider has a github_access_token' do
        before { allow(project_credential_provider).to receive(:github_access_token).and_return('project_token') }

        it 'returns the project_credential_provider github_access_token' do
          expect(project.github_access_token).to eq('project_token')
        end
      end

      context 'when project_credential_provider does not have a github_access_token' do
        before { allow(account).to receive(:github_access_token).and_return('account_token') }

        it 'returns the account github_access_token' do
          expect(project.github_access_token).to eq('account_token')
        end
      end
    end

    describe '#container_registry_url' do
      it 'returns the container registry URL' do
        expect(project.container_registry_url).to eq('ghcr.io/owner/repository:latest')
      end
    end

    describe '#deployable?' do
      context 'when there are services' do
        it 'returns true' do
          expect(project.deployable?).to be_truthy
        end
      end

      context 'when there are no services' do
        before { project.services.destroy_all }

        it 'returns false' do
          expect(project.deployable?).to be_falsey
        end
      end
    end

    describe '#has_updates?' do
      context 'when services have updates' do
        before do
          allow_any_instance_of(Service).to receive(:updated?).and_return(true)
        end

        it 'returns true' do
          expect(project.has_updates?).to be_truthy
        end
      end

      context 'when services have pending updates' do
        before do
          allow_any_instance_of(Service).to receive(:pending?).and_return(true)
        end

        it 'returns true' do
          expect(project.has_updates?).to be_truthy
        end
      end

      context 'when services have no updates' do
        before do
          allow_any_instance_of(Service).to receive(:updated?).and_return(false)
          allow_any_instance_of(Service).to receive(:pending?).and_return(false)
        end

        it 'returns false' do
          expect(project.has_updates?).to be_falsey
        end
      end
    end

    describe '#updated!' do
      it 'calls updated! on each service' do
        project.services.each do |service|
          expect(service).to receive(:updated!)
        end

        project.updated!
      end
    end
  end
end
